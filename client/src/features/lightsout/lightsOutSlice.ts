import { PayloadAction, createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { Solution, solve } from "./lightsOutAPI";
import { boardSize, columnCount, rowCount } from "./constants";
import { RootState } from "../../app/store";

export type LightsOutStatus =
  | "setup"
  | "loading"
  | "solution"
  | "nosolution"
  | "done";

export interface LightsOutState {
  status: LightsOutStatus;
  board: boolean[];
  solution?: boolean[];
  showErrorMessage: boolean;
}

const initialState: LightsOutState = {
  status: "setup",
  board: new Array<boolean>(boardSize).fill(false),
  showErrorMessage: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const solveAsync = createAsyncThunk<
  Solution,
  void,
  { state: RootState }
>("lightsOut/solve", async (_, { getState }) => {
  const board = selectBoard(getState());
  return solve(board);
});

export const lightsOutSlice = createSlice({
  name: "counter",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    reset: (state) => {
      state.status = "setup";
      state.board = initialState.board;
      state.solution = undefined;
    },
    modify: (state) => {
      state.status = "setup";
    },
    clickTile: (state, action: PayloadAction<number>) => {
      if (state.status === "setup") {
        state.board[action.payload] = !state.board[action.payload];
      } else if (state.status === "solution" && state.solution) {
        state.board[action.payload] = !state.board[action.payload];
        if (action.payload > columnCount - 1) {
          state.board[action.payload - columnCount] =
            !state.board[action.payload - columnCount];
        }
        if (action.payload < (rowCount - 1) * columnCount) {
          state.board[action.payload + columnCount] =
            !state.board[action.payload + columnCount];
        }
        if (action.payload % columnCount > 0) {
          state.board[action.payload - 1] = !state.board[action.payload - 1];
        }
        if (action.payload % columnCount < columnCount - 1) {
          state.board[action.payload + 1] = !state.board[action.payload + 1];
        }

        state.solution[action.payload] = !state.solution[action.payload];

        if (state.board.every((tile) => !tile)) {
          state.status = "done";
        }
      }
    },
    closeErrorMessage: (state) => {
      state.showErrorMessage = false;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(solveAsync.pending, (state) => {
        state.status = "loading";
      })
      .addCase(solveAsync.fulfilled, (state, action) => {
        if (!action.payload.hasSolution || !action.payload.solution) {
          state.status = "nosolution";
        } else {
          state.status = "solution";

          const solution = new Array<boolean>(boardSize).fill(false);
          for (let index of action.payload.solution) {
            solution[index] = true;
          }
          state.solution = solution;
        }
      })
      .addCase(solveAsync.rejected, (state, action) => {
        console.log(action.error);

        state.status = "setup";
        state.showErrorMessage = true;
      });
  },
});

export const { reset, modify, clickTile, closeErrorMessage } =
  lightsOutSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file.
export const selectStatus = (state: RootState) => state.lightsOut.status;
export const selectBoard = (state: RootState) => state.lightsOut.board;
export const selectTile = (index: number) => (state: RootState) => ({
  lit: state.lightsOut.board[index],
  partOfSolution: state.lightsOut.solution
    ? state.lightsOut.solution[index]
    : undefined,
});
export const selectShowErrorMessage = (state: RootState) =>
  state.lightsOut.showErrorMessage;

export default lightsOutSlice.reducer;
